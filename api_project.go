/*
 * Harbor API
 *
 * These APIs provide services for manipulating Harbor project.
 *
 * API version: 2.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"fmt"
	"github.com/antihax/optional"
	"github.com/pkg/errors"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type ProjectApiService service

/*
ProjectApiService Create a new project.
This endpoint is for user to create a new project.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param project New created project.
 * @param optional nil or *ProjectApiCreateProjectOpts - Optional Parameters:
     * @param "XRequestId" (optional.String) -  An unique ID for the request
     * @param "XResourceNameInLocation" (optional.Bool) -  The flag to indicate whether to return the name of the resource in Location. When X-Resource-Name-In-Location is true, the Location will return the name of the resource.


*/

type ProjectApiCreateProjectOpts struct {
	XRequestId              optional.String
	XResourceNameInLocation optional.Bool
}

func (a *ProjectApiService) CreateProject(ctx context.Context, project ProjectReq, localVarOptionals *ProjectApiCreateProjectOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XRequestId.IsSet() {
		localVarHeaderParams["X-Request-Id"] = parameterToString(localVarOptionals.XRequestId.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.XResourceNameInLocation.IsSet() {
		localVarHeaderParams["X-Resource-Name-In-Location"] = parameterToString(localVarOptionals.XResourceNameInLocation.Value(), "")
	}
	// body params
	localVarPostBody = &project
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, errors.WithStack(err)
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, errors.WithStack(err)
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 401 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 409 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		return localVarHttpResponse, errors.WithStack(newErr)
	}

	return localVarHttpResponse, nil
}

/*
ProjectApiService Delete project by projectID
This endpoint is aimed to delete project by project ID.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectNameOrId The name or id of the project
 * @param optional nil or *ProjectApiDeleteProjectOpts - Optional Parameters:
     * @param "XRequestId" (optional.String) -  An unique ID for the request
     * @param "XIsResourceName" (optional.Bool) -  The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.


*/

type ProjectApiDeleteProjectOpts struct {
	XRequestId      optional.String
	XIsResourceName optional.Bool
}

func (a *ProjectApiService) DeleteProject(ctx context.Context, projectNameOrId string, localVarOptionals *ProjectApiDeleteProjectOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/projects/{project_name_or_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_name_or_id"+"}", fmt.Sprintf("%v", projectNameOrId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XRequestId.IsSet() {
		localVarHeaderParams["X-Request-Id"] = parameterToString(localVarOptionals.XRequestId.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.XIsResourceName.IsSet() {
		localVarHeaderParams["X-Is-Resource-Name"] = parameterToString(localVarOptionals.XIsResourceName.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, errors.WithStack(err)
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, errors.WithStack(err)
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 412 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		return localVarHttpResponse, errors.WithStack(newErr)
	}

	return localVarHttpResponse, nil
}

/*
ProjectApiService Get recent logs of the projects
Get recent logs of the projects
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectName The name of the project
 * @param optional nil or *ProjectApiGetLogsOpts - Optional Parameters:
     * @param "XRequestId" (optional.String) -  An unique ID for the request
     * @param "Q" (optional.String) -  Query string to query resources. Supported query patterns are \&quot;exact match(k&#x3D;v)\&quot;, \&quot;fuzzy match(k&#x3D;~v)\&quot;, \&quot;range(k&#x3D;[min~max])\&quot;, \&quot;list with union releationship(k&#x3D;{v1 v2 v3})\&quot; and \&quot;list with intersetion relationship(k&#x3D;(v1 v2 v3))\&quot;. The value of range and list can be string(enclosed by \&quot; or &#39;), integer or time(in format \&quot;2020-04-09 02:36:00\&quot;). All of these query patterns should be put in the query string \&quot;q&#x3D;xxx\&quot; and splitted by \&quot;,\&quot;. e.g. q&#x3D;k1&#x3D;v1,k2&#x3D;~v2,k3&#x3D;[min~max]
     * @param "Sort" (optional.String) -  Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \&quot;sort&#x3D;field1,-field2\&quot;
     * @param "Page" (optional.Int64) -  The page number
     * @param "PageSize" (optional.Int64) -  The size of per page

@return []AuditLog
*/

type ProjectApiGetLogsOpts struct {
	XRequestId optional.String
	Q          optional.String
	Sort       optional.String
	Page       optional.Int64
	PageSize   optional.Int64
}

func (a *ProjectApiService) GetLogs(ctx context.Context, projectName string, localVarOptionals *ProjectApiGetLogsOpts) ([]AuditLog, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []AuditLog
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/projects/{project_name}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"project_name"+"}", fmt.Sprintf("%v", projectName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XRequestId.IsSet() {
		localVarHeaderParams["X-Request-Id"] = parameterToString(localVarOptionals.XRequestId.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, errors.WithStack(err)
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []AuditLog
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 401 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProjectApiService Return specific project detail information
This endpoint returns specific project information by project ID.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectNameOrId The name or id of the project
 * @param optional nil or *ProjectApiGetProjectOpts - Optional Parameters:
     * @param "XRequestId" (optional.String) -  An unique ID for the request
     * @param "XIsResourceName" (optional.Bool) -  The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.

@return Project
*/

type ProjectApiGetProjectOpts struct {
	XRequestId      optional.String
	XIsResourceName optional.Bool
}

func (a *ProjectApiService) GetProject(ctx context.Context, projectNameOrId string, localVarOptionals *ProjectApiGetProjectOpts) (Project, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Project
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/projects/{project_name_or_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_name_or_id"+"}", fmt.Sprintf("%v", projectNameOrId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XRequestId.IsSet() {
		localVarHeaderParams["X-Request-Id"] = parameterToString(localVarOptionals.XRequestId.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.XIsResourceName.IsSet() {
		localVarHeaderParams["X-Is-Resource-Name"] = parameterToString(localVarOptionals.XIsResourceName.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, errors.WithStack(err)
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v Project
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 401 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProjectApiService Get the deletable status of the project
Get the deletable status of the project
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectNameOrId The name or id of the project
 * @param optional nil or *ProjectApiGetProjectDeletableOpts - Optional Parameters:
     * @param "XRequestId" (optional.String) -  An unique ID for the request
     * @param "XIsResourceName" (optional.Bool) -  The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.

@return ProjectDeletable
*/

type ProjectApiGetProjectDeletableOpts struct {
	XRequestId      optional.String
	XIsResourceName optional.Bool
}

func (a *ProjectApiService) GetProjectDeletable(ctx context.Context, projectNameOrId string, localVarOptionals *ProjectApiGetProjectDeletableOpts) (ProjectDeletable, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ProjectDeletable
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/projects/{project_name_or_id}/_deletable"
	localVarPath = strings.Replace(localVarPath, "{"+"project_name_or_id"+"}", fmt.Sprintf("%v", projectNameOrId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XRequestId.IsSet() {
		localVarHeaderParams["X-Request-Id"] = parameterToString(localVarOptionals.XRequestId.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.XIsResourceName.IsSet() {
		localVarHeaderParams["X-Is-Resource-Name"] = parameterToString(localVarOptionals.XIsResourceName.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, errors.WithStack(err)
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ProjectDeletable
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 401 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProjectApiService Get summary of the project.
Get summary of the project.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectNameOrId The name or id of the project
 * @param optional nil or *ProjectApiGetProjectSummaryOpts - Optional Parameters:
     * @param "XRequestId" (optional.String) -  An unique ID for the request
     * @param "XIsResourceName" (optional.Bool) -  The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.

@return ProjectSummary
*/

type ProjectApiGetProjectSummaryOpts struct {
	XRequestId      optional.String
	XIsResourceName optional.Bool
}

func (a *ProjectApiService) GetProjectSummary(ctx context.Context, projectNameOrId string, localVarOptionals *ProjectApiGetProjectSummaryOpts) (ProjectSummary, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ProjectSummary
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/projects/{project_name_or_id}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"project_name_or_id"+"}", fmt.Sprintf("%v", projectNameOrId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XRequestId.IsSet() {
		localVarHeaderParams["X-Request-Id"] = parameterToString(localVarOptionals.XRequestId.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.XIsResourceName.IsSet() {
		localVarHeaderParams["X-Is-Resource-Name"] = parameterToString(localVarOptionals.XIsResourceName.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, errors.WithStack(err)
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ProjectSummary
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 401 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProjectApiService Get project level scanner
Get the scanner registration of the specified project. If no scanner registration is configured for the specified project, the system default scanner registration will be returned.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectNameOrId The name or id of the project
 * @param optional nil or *ProjectApiGetScannerOfProjectOpts - Optional Parameters:
     * @param "XRequestId" (optional.String) -  An unique ID for the request
     * @param "XIsResourceName" (optional.Bool) -  The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.

@return ScannerRegistration
*/

type ProjectApiGetScannerOfProjectOpts struct {
	XRequestId      optional.String
	XIsResourceName optional.Bool
}

func (a *ProjectApiService) GetScannerOfProject(ctx context.Context, projectNameOrId string, localVarOptionals *ProjectApiGetScannerOfProjectOpts) (ScannerRegistration, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ScannerRegistration
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/projects/{project_name_or_id}/scanner"
	localVarPath = strings.Replace(localVarPath, "{"+"project_name_or_id"+"}", fmt.Sprintf("%v", projectNameOrId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XRequestId.IsSet() {
		localVarHeaderParams["X-Request-Id"] = parameterToString(localVarOptionals.XRequestId.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.XIsResourceName.IsSet() {
		localVarHeaderParams["X-Is-Resource-Name"] = parameterToString(localVarOptionals.XIsResourceName.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, errors.WithStack(err)
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ScannerRegistration
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProjectApiService Check if the project name user provided already exists.
This endpoint is used to check if the project name provided already exist.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectName Project name for checking exists.
 * @param optional nil or *ProjectApiHeadProjectOpts - Optional Parameters:
     * @param "XRequestId" (optional.String) -  An unique ID for the request


*/

type ProjectApiHeadProjectOpts struct {
	XRequestId optional.String
}

func (a *ProjectApiService) HeadProject(ctx context.Context, projectName string, localVarOptionals *ProjectApiHeadProjectOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Head")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("project_name", parameterToString(projectName, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XRequestId.IsSet() {
		localVarHeaderParams["X-Request-Id"] = parameterToString(localVarOptionals.XRequestId.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, errors.WithStack(err)
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, errors.WithStack(err)
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		return localVarHttpResponse, errors.WithStack(newErr)
	}

	return localVarHttpResponse, nil
}

/*
ProjectApiService List projects
This endpoint returns projects created by Harbor.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProjectApiListProjectsOpts - Optional Parameters:
     * @param "XRequestId" (optional.String) -  An unique ID for the request
     * @param "Q" (optional.String) -  Query string to query resources. Supported query patterns are \&quot;exact match(k&#x3D;v)\&quot;, \&quot;fuzzy match(k&#x3D;~v)\&quot;, \&quot;range(k&#x3D;[min~max])\&quot;, \&quot;list with union releationship(k&#x3D;{v1 v2 v3})\&quot; and \&quot;list with intersetion relationship(k&#x3D;(v1 v2 v3))\&quot;. The value of range and list can be string(enclosed by \&quot; or &#39;), integer or time(in format \&quot;2020-04-09 02:36:00\&quot;). All of these query patterns should be put in the query string \&quot;q&#x3D;xxx\&quot; and splitted by \&quot;,\&quot;. e.g. q&#x3D;k1&#x3D;v1,k2&#x3D;~v2,k3&#x3D;[min~max]
     * @param "Page" (optional.Int64) -  The page number
     * @param "PageSize" (optional.Int64) -  The size of per page
     * @param "Sort" (optional.String) -  Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \&quot;sort&#x3D;field1,-field2\&quot;
     * @param "Name" (optional.String) -  The name of project.
     * @param "Public" (optional.Bool) -  The project is public or private.
     * @param "Owner" (optional.String) -  The name of project owner.
     * @param "WithDetail" (optional.Bool) -  Bool value indicating whether return detailed information of the project

@return []Project
*/

type ProjectApiListProjectsOpts struct {
	XRequestId optional.String
	Q          optional.String
	Page       optional.Int64
	PageSize   optional.Int64
	Sort       optional.String
	Name       optional.String
	Public     optional.Bool
	Owner      optional.String
	WithDetail optional.Bool
}

func (a *ProjectApiService) ListProjects(ctx context.Context, localVarOptionals *ProjectApiListProjectsOpts) ([]Project, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []Project
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Public.IsSet() {
		localVarQueryParams.Add("public", parameterToString(localVarOptionals.Public.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Owner.IsSet() {
		localVarQueryParams.Add("owner", parameterToString(localVarOptionals.Owner.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithDetail.IsSet() {
		localVarQueryParams.Add("with_detail", parameterToString(localVarOptionals.WithDetail.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XRequestId.IsSet() {
		localVarHeaderParams["X-Request-Id"] = parameterToString(localVarOptionals.XRequestId.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, errors.WithStack(err)
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []Project
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 401 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProjectApiService Get scanner registration candidates for configurating project level scanner
Retrieve the system configured scanner registrations as candidates of setting project level scanner.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectNameOrId The name or id of the project
 * @param optional nil or *ProjectApiListScannerCandidatesOfProjectOpts - Optional Parameters:
     * @param "XRequestId" (optional.String) -  An unique ID for the request
     * @param "XIsResourceName" (optional.Bool) -  The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.
     * @param "Q" (optional.String) -  Query string to query resources. Supported query patterns are \&quot;exact match(k&#x3D;v)\&quot;, \&quot;fuzzy match(k&#x3D;~v)\&quot;, \&quot;range(k&#x3D;[min~max])\&quot;, \&quot;list with union releationship(k&#x3D;{v1 v2 v3})\&quot; and \&quot;list with intersetion relationship(k&#x3D;(v1 v2 v3))\&quot;. The value of range and list can be string(enclosed by \&quot; or &#39;), integer or time(in format \&quot;2020-04-09 02:36:00\&quot;). All of these query patterns should be put in the query string \&quot;q&#x3D;xxx\&quot; and splitted by \&quot;,\&quot;. e.g. q&#x3D;k1&#x3D;v1,k2&#x3D;~v2,k3&#x3D;[min~max]
     * @param "Sort" (optional.String) -  Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with \&quot;sort&#x3D;field1,-field2\&quot;
     * @param "Page" (optional.Int64) -  The page number
     * @param "PageSize" (optional.Int64) -  The size of per page

@return []ScannerRegistration
*/

type ProjectApiListScannerCandidatesOfProjectOpts struct {
	XRequestId      optional.String
	XIsResourceName optional.Bool
	Q               optional.String
	Sort            optional.String
	Page            optional.Int64
	PageSize        optional.Int64
}

func (a *ProjectApiService) ListScannerCandidatesOfProject(ctx context.Context, projectNameOrId string, localVarOptionals *ProjectApiListScannerCandidatesOfProjectOpts) ([]ScannerRegistration, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []ScannerRegistration
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/projects/{project_name_or_id}/scanner/candidates"
	localVarPath = strings.Replace(localVarPath, "{"+"project_name_or_id"+"}", fmt.Sprintf("%v", projectNameOrId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XRequestId.IsSet() {
		localVarHeaderParams["X-Request-Id"] = parameterToString(localVarOptionals.XRequestId.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.XIsResourceName.IsSet() {
		localVarHeaderParams["X-Is-Resource-Name"] = parameterToString(localVarOptionals.XIsResourceName.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, errors.WithStack(err)
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		return localVarReturnValue, localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v []ScannerRegistration
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 401 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
		}

		return localVarReturnValue, localVarHttpResponse, errors.WithStack(newErr)
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ProjectApiService Configure scanner for the specified project
Set one of the system configured scanner registration as the indepndent scanner of the specified project.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectNameOrId The name or id of the project
 * @param payload
 * @param optional nil or *ProjectApiSetScannerOfProjectOpts - Optional Parameters:
     * @param "XRequestId" (optional.String) -  An unique ID for the request
     * @param "XIsResourceName" (optional.Bool) -  The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.


*/

type ProjectApiSetScannerOfProjectOpts struct {
	XRequestId      optional.String
	XIsResourceName optional.Bool
}

func (a *ProjectApiService) SetScannerOfProject(ctx context.Context, projectNameOrId string, payload ProjectScanner, localVarOptionals *ProjectApiSetScannerOfProjectOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/projects/{project_name_or_id}/scanner"
	localVarPath = strings.Replace(localVarPath, "{"+"project_name_or_id"+"}", fmt.Sprintf("%v", projectNameOrId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XRequestId.IsSet() {
		localVarHeaderParams["X-Request-Id"] = parameterToString(localVarOptionals.XRequestId.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.XIsResourceName.IsSet() {
		localVarHeaderParams["X-Is-Resource-Name"] = parameterToString(localVarOptionals.XIsResourceName.Value(), "")
	}
	// body params
	localVarPostBody = &payload
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, errors.WithStack(err)
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, errors.WithStack(err)
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 401 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		return localVarHttpResponse, errors.WithStack(newErr)
	}

	return localVarHttpResponse, nil
}

/*
ProjectApiService Update properties for a selected project.
This endpoint is aimed to update the properties of a project.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectNameOrId The name or id of the project
 * @param project Updates of project.
 * @param optional nil or *ProjectApiUpdateProjectOpts - Optional Parameters:
     * @param "XRequestId" (optional.String) -  An unique ID for the request
     * @param "XIsResourceName" (optional.Bool) -  The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.


*/

type ProjectApiUpdateProjectOpts struct {
	XRequestId      optional.String
	XIsResourceName optional.Bool
}

func (a *ProjectApiService) UpdateProject(ctx context.Context, projectNameOrId string, project ProjectReq, localVarOptionals *ProjectApiUpdateProjectOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/projects/{project_name_or_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_name_or_id"+"}", fmt.Sprintf("%v", projectNameOrId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XRequestId.IsSet() {
		localVarHeaderParams["X-Request-Id"] = parameterToString(localVarOptionals.XRequestId.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.XIsResourceName.IsSet() {
		localVarHeaderParams["X-Is-Resource-Name"] = parameterToString(localVarOptionals.XIsResourceName.Value(), "")
	}
	// body params
	localVarPostBody = &project
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, errors.WithStack(err)
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, errors.WithStack(err)
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, errors.WithStack(err)
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 401 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 404 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		if localVarHttpResponse.StatusCode == 500 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHttpResponse, errors.WithStack(newErr)
			}
			newErr.model = v
			return localVarHttpResponse, errors.WithStack(newErr)
		}

		return localVarHttpResponse, errors.WithStack(newErr)
	}

	return localVarHttpResponse, nil
}
